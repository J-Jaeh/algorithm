'''
시간복잡도란?..
입력값과 문제를 해결하는 데 걸리는 시간과의 상관관계를 말합니다!
입력값이 2배로 늘어났을 때 문제를 해결하는 데 걸리는 시간은 몇 배로 늘어나는지를 보는 것이죠.
우리는 시간이 적게 걸리는 알고리즘을 좋아하니 입력값이 늘어나도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘이겠죠?

'''

for num in array:  # array 의 길이만큼 아래 연산이 실행
    for compare_num in array:  # array 의 길이만큼 아래 연산이 실행
        if num < compare_num:  # 비교 연산 1번 실행
            break
    else:
        return num
'''
- 위에서 연산된 것들을 더해보면,
    1. array의 길이 X array의 길이 X 비교 연산 1번
    
    만큼의 시간이 필요합니다. 여기서 array(입력값)의 길이는 보통 N이라고 표현합니다. 그러면 위의 시간을 다음과 같이 표현할 수 있습니다.
    
    $$
    N \times  N
    $$
    
    그러면 우리는 이제 이 함수는 $N^2$ 만큼의 **시간이 걸렸겠구나**! 라고 말할 수 있습니다.

 
'''
for num in array:  # array 의 길이만큼 아래 연산이 실행
    if num > max_num:  # 비교 연산 1번 실행
        max_num = num  # 대입 연산 1번 실행

'''
- 위에서 연산된 것들을 더해보면,
    1. max_num 대입 연산 1번
    2. array의 길이 X (비교 연산 1번 + 대입 연산 1번) 
    
    만큼의 시간이 필요합니다. 첫 번째 방법에서 했던 것처럼 array 의 길이를 N이라고 하면, 다음과 같이 표현할 수 있겠죠?
    
    $$
    1+2\times N
    $$
    
    그러면 우리는 이제 이 함수는 $2N+1$ 만큼의 **시간이 걸렸겠구나**! 라고 말할 수 있습니다.
    
    
    
    - 표를 보면, 두 가지를 깨달을 수 있습니다.
    1.  $N$ 과 $N^2$ 은 N 이 커질수록 더 큰 차이가 나는구나!
    2.  $N$의 지수를 먼저 비교하면 되겠구나.
    
- 그러나, 저희가 매번 코드를 매 실행 단위로 이렇게 몇 번의 연산이 발생하는지 확인하는 건 불가능합니다. 
따라서 **상수는 신경쓰지말고**, 입력값에 비례해서 어느 정도로 증가하는지만 파악하면 됩니다.

<aside>
💡 즉, $2N+1$의 연산량이 나온 첫번째 풀이 방법은 $N$ 만큼의 연산량이 필요하다
$N^2$ 의 연산량이 나온 두번째 풀이 방법은 $N^2$ 만큼의 연산량이 필요하다.

참고로, 만약 상수의 연산량이 필요하다면, $1$ 만큼의 연산량이 필요하다고 말하면 됩니다.

</aside>
'''